#!/bin/sh /etc/rc.common
PKG_VERSION=

export START=94
export USE_PROCD=1

readonly A_TMP='/var/hosts.allowed.tmp'
readonly B_TMP='/var/hosts.blocked.tmp'
readonly T_TMP='/var/simple-adblock.hosts'
readonly h_filter='/localhost/d;/^#/d;/^[^0-9]/d;s/^0\.0\.0\.0.//;s/^127\.0\.0\.1.//;s/[[:space:]]*#.*$//;s/[[:cntrl:]]$//;s/[[:space:]]//g;/[`~!@#\$%\^&\*()=+;:"'\'',<>?/\|[{}]/d;/]/d;/\./!d;/^$/d;'
readonly d_filter='/^#/d;s/[[:space:]]*#.*$//;s/[[:space:]]*$//;s/[[:cntrl:]]$//;/[[:space:]]/d;/[`~!@#\$%\^&\*()=+;:"'\'',<>?/\|[{}]/d;/]/d;/\./!d;/^$/d;'
readonly f_filter='s|^|local=/|;s|$|/|'
readonly _OK_='\033[0;32m\xe2\x9c\x93\033[0m'
readonly _FAIL_='\033[0;31m\xe2\x9c\x97\033[0m'
readonly __OK__='\033[0;32m[\xe2\x9c\x93]\033[0m'
readonly __FAIL__='\033[0;31m[\xe2\x9c\x97]\033[0m'
readonly _ERROR_='\033[0;31mERROR\033[0m'

export EXTRA_COMMANDS="check killcache"
export EXTRA_HELP="	check	Checks if specified domain is found in current blacklist"

readonly packageName='simple-adblock'
readonly serviceName="$packageName $PKG_VERSION"
readonly PID="/var/run/${packageName}.pid"
create_lock() { [ -e "$PID" ] && return 1; touch "$PID"; }
remove_lock() { [ -e "$PID" ] && rm -f "$PID"; }
trap remove_lock EXIT
output_ok() { case $verbosity in 1) output "$_OK_";; 2) output "$__OK__\n";; esac; }
output_okn() { case $verbosity in 1) output "$_OK_\n";; 2) output "$__OK__\n";; esac; }
output_fail() { case $verbosity in 1) output "$_FAIL_";; 2) output "$__FAIL__\n";; esac; }
output_failn() { case $verbosity in 1) output "$_FAIL_\n";; 2) output "$__FAIL__\n";; esac; }
output() { [[ $# -ne 1 ]] && { [[ ! $((verbosity & $1)) -gt 0 ]] && return 0 || shift; }; local msg; msg=$(echo -n "${1/$serviceName /service }" | sed 's|\\033\[[0-9]\?;\?[0-9]\?[0-9]\?m||g'); [[ -t 1 ]] && echo -e -n "$1"; [[ $(echo -e -n "$msg" | wc -l) -gt 0 ]] && logger -t "${packageName:-service} [$$]" "$(echo -e -n ${logmsg}${msg})" && logmsg='' || logmsg=${logmsg}${msg}; }
led_on(){ [[ -n "$led" && -e "$led/trigger" ]] && echo "default-on" > "$led/trigger"; }
led_off(){ [[ -n "$led" && -e "$led/trigger" ]] && echo "none" > "$led/trigger"; }
export serviceEnabled verbosity forceDNS debug led wan_if wan_gw wanphysdev dnsmasqFile bootDelay dl_command

boot() { load_package_config; ( sleep $bootDelay && rc_procd start_service && rc_procd service_triggers | cat & ); }

load_package_config() {
	config_load "$packageName"
	config_get_bool serviceEnabled 'config' 'enabled' 1
	config_get_bool forceDNS       'config' 'force_dns' 1
	config_get_bool debug          'config' 'debug' 0
	config_get bootDelay           'config' 'boot_delay' '120'
	config_get dlTimeout           'config' 'download_timeout' '10'
	config_get verbosity           'config' 'verbosity' '2'
	config_get dnsmasqFile  	     'config' 'hosts_file' "/var/dnsmasq.d/${packageName}"
	config_get led        	       'config' 'led'
	source /lib/functions/network.sh
	dl_command="wget --no-check-certificate --timeout $dlTimeout -qO-"
}

is_enabled() {
		local sleepCount=1
		load_package_config

		if [ "$debug" -ne 0 ]; then
			exec 1>>/tmp/simple-adblock.log
			exec 2>&1
			set -x
		fi

		led="${led:+/sys/class/leds/$led}"
		[ $serviceEnabled -gt 0 ] || return 1
		network_flush_cache; network_find_wan wan_if;	network_get_gateway wan_gw $wan_if;
		[ -n "$wan_gw" ] && return 0
		output "$_ERROR_: $serviceName failed to discover WAN gateway.\n"; return 1;
}

process_url() {
	local label type D_TMP R_TMP
	[[ -n "$1" && -n "$2" && -n "$3" ]] || return 1
#	ping -W5 -c1 "$(echo $1 | awk -F '/' '{print $3}')" 1>/dev/null 2>/dev/null || { output_fail; return 1; }
	[ "$2" == "hosts" ] && label="Hosts: $(echo $1 | cut -d'/' -f3)" filter="$h_filter" || label="Domains: $(echo $1 | cut -d'/' -f3)" filter="$d_filter"
	[ "$3" == "blocked" ] && { type='Blocked'; D_TMP="$B_TMP"; } || { type='Allowed'; D_TMP="$A_TMP"; }
	R_TMP="/var/simple-adblock_$(head -c40 /dev/urandom 2>/dev/null | tr -dc 'A-Za-z0-9' 2>/dev/null)"
	while [ -e "$R_TMP" ]; do R_TMP="/var/simple-adblock_$(head -c40 /dev/urandom 2>/dev/null | tr -dc 'A-Za-z0-9' 2>/dev/null)"; done
	touch "$R_TMP"
    output 2 "[DL] $type $label "
    $dl_command "$1" > "$R_TMP" 2>/dev/null && output_ok || output_fail
	{ sed -i "$filter" "$R_TMP"; cat "$R_TMP" >> "$D_TMP"; rm -f "$R_TMP"; } &
}

download_lists() {
	local i hf w_filter whitelist_domains blacklist_domains whitelist_domains_urls blacklist_domains_urls blacklist_hosts_urls
  config_get whitelist_domains          'config' 'whitelist_domain'
  config_get blacklist_domains          'config' 'blacklist_domain'
  config_get whitelist_domains_urls     'config' 'whitelist_domains_url'
  config_get blacklist_domains_urls     'config' 'blacklist_domains_url'
  config_get blacklist_hosts_urls       'config' 'blacklist_hosts_url'

	[ ! -d ${dnsmasqFile%/*} ] && mkdir -p ${dnsmasqFile%/*}
	for i in $A_TMP $B_TMP $T_TMP $dnsmasqFile; do [ -f $i ] && rm -f $i; done
	if [ "$(awk '/^MemFree/ {print int($2/1000)}' "/proc/meminfo")" -lt 32 ]; then
		output 1 'Low free memory, restarting dnsmasq...'
		reload_dnsmasq 'quiet' && output_okn || output_failn
	fi
  touch $A_TMP; touch $B_TMP; touch $T_TMP;
  if [ -n "$blacklist_hosts_urls" ]; then
    output 1 '[DL] Blocked Hosts '
    for hf in ${blacklist_hosts_urls}; do process_url "$hf" 'hosts' 'blocked'; done
		output 1 '\n'
	fi
  if [ -n "$blacklist_domains_urls" ]; then
    output 1 '[DL] Blocked Domains '
    for hf in ${blacklist_domains_urls}; do process_url "$hf" 'domains' 'blocked'; done
		output 1 '\n'
	fi
  if [ -n "$whitelist_domains_urls" ]; then
    output 1 '[DL] Allowed Domains '
    for hf in ${whitelist_domains_urls}; do process_url "$hf" 'domains' 'allowed'; done
		output 1 '\n'
	fi
	output 3 'Waiting for background processes '
	wait && output_okn
  [ -n "$blacklist_domains" ] && for hf in ${blacklist_domains}; do echo "$hf" | sed "$d_filter" >> $B_TMP; done
  whitelist_domains="${whitelist_domains}"$'\n'"$(cat $A_TMP)"
  [ -n "$whitelist_domains" ] && for hf in ${whitelist_domains}; do hf=$(echo $hf | sed 's/\./\\./g'); w_filter="$w_filter/^${hf}$/d;/\\.${hf}$/d;"; done
	if [ -s $B_TMP ]; then
	    output 1 'Processing downloads '
	    output 2 'Sorting merged file '; sort $B_TMP | uniq > $T_TMP && output_ok || output_fail
	    output 2 'Whitelisting domains '; sed -i "$w_filter" $T_TMP && output_ok || output_fail
	    output 2 'Formatting merged file '; sed "$f_filter" $T_TMP > $B_TMP && mv $B_TMP $dnsmasqFile && output_ok || output_fail
	    output 1 '\n'
	    output 3 'Removing temporary files '
			[ -f $A_TMP ] && rm -f $A_TMP; [ -f $B_TMP ] && rm -f $B_TMP; [ -f $T_TMP ] && rm -f $T_TMP;
		  output_okn
	fi
}

reload_dnsmasq() {
	case $1 in
		on_start)
			if [ -s $dnsmasqFile ]; then
				output 3 'Restarting dnsmasq '
				killall -q -HUP dnsmasq
				if [[ $? -eq 0 ]]; then
					led_on; output_okn;
					output "$serviceName blocking $(wc -l < $dnsmasqFile) domains $_OK_\n"
				else
					output_failn; output "$_ERROR_: $serviceName failed to restart dnsmasq!\n";
					return 1
				fi
			else
				output "$_ERROR_: $serviceName failed to create its data file!\n"
				return 1
			fi
			;;
		on_stop)
			[ -f $dnsmasqFile ] && mv $dnsmasqFile $T_TMP
			output 3 'Restarting dnsmasq '
			killall -q -HUP dnsmasq
			if [[ $? -eq 0 ]]; then
				led_off; output_okn;
				output "$serviceName stopped.\n";
			else
				output_failn;
				output "$_ERROR_: $serviceName failed to restart dnsmasq!\n";
			fi
			;;
		quiet | *)
			killall -q -HUP dnsmasq && return 0 || return 1
			;;
	esac
}

check() {
	load_package_config
	local string="$1"
	if [ ! -f $dnsmasqFile ]; then
		echo "No local blacklist ($dnsmasqFile) found."
	elif [ -z "$string" ]; then
		echo "Usage: /etc/init.d/${serviceName} check 'domain'"
	elif grep -m1 -q $string $dnsmasqFile; then
		echo "Found $(grep $string $dnsmasqFile | wc -l) matches for $string in $dnsmasqFile:"
		grep $string $dnsmasqFile | sed 's|local=/||;s|/$||;'
	else
		echo "The $string is not found in current blacklist."
	fi
}

start_service() {
	if create_lock; then
	  is_enabled || return 1
		procd_open_instance
		procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}
		procd_set_param stdout 1
		procd_set_param stderr 1
		if [ $forceDNS -ne 0 ]; then
			procd_open_data
			json_add_array firewall
			json_add_object ""
			json_add_string type redirect
			json_add_string target 'DNAT'
			json_add_string src 'lan'
			json_add_string proto 'tcpudp'
			json_add_string src_dport '53'
			json_add_string dest_port '53'
			json_add_string name 'simple_adblock_dns'
			json_add_string reflection '0'
			json_close_object
			json_close_array
			procd_close_data
		fi
		procd_close_instance
		if [ "$1" == "reload" ]; then
			output "Reloading $serviceName...\n"
			download_lists
			reload_dnsmasq 'on_start'
		elif [ -s "$dnsmasqFile" ]; then
			output "$serviceName is already running...\n"
		elif [ -s "$T_TMP" ]; then
			output "Starting $serviceName...\n"
			output 3 'Found existing data file, reusing it... '
			mv $T_TMP $dnsmasqFile && output_okn || output_failn
			reload_dnsmasq 'on_start'
		else
			output "Starting $serviceName...\n"
			download_lists
			reload_dnsmasq 'on_start'
		fi
		remove_lock
	else
		output "$serviceName: another instance of ${packageName} is currently running "; output_failn;
		return 1
	fi
}

service_started() { procd_set_config_changed firewall; }
reload_service() { start_service 'reload'; }
killcache() { [ -s $T_TMP ] && rm -f $T_TMP; }

stop_service() {
	load_package_config
	output "Stopping $serviceName...\n"
	reload_dnsmasq 'on_stop'
	procd_set_config_changed firewall
}
